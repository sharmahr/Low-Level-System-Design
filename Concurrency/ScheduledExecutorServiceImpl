package concurrency;

// Implement the following method of ScheduledExecutorService interface in java:
// public class ScheduledExecutorService {

// 	/**
// 	* Creates and executes a one-shot action that becomes enabled after the given delay.
// 	*/
// 	public void schedule(Runnable command, long delay, TimeUnit unit) {
// 	}

// 	/**
// 	* Creates and executes a periodic action that becomes enabled first after the given initial delay, and 
// 	* subsequently with the given period; that is executions will commence after initialDelay then 
// 	* initialDelay+period, then initialDelay + 2 * period, and so on.
// 	*/
// 	public void scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
// 	}

// 	/*
// 	* Creates and executes a periodic action that becomes enabled first after the given initial delay, and 
// 	* subsequently with the given delay between the termination of one execution and the commencement of the next.
// 	*/
// 	public void scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
// 	}

// }


import java.util.concurrent.*;

public class ScheduledExecutorServiceImpl implements ScheduledExecutorService {
    private final ExecutorService executorService;
    private final ScheduledExecutorService scheduledExecutorService;

    public ScheduledExecutorServiceImpl(int corePoolSize) {
        this.executorService = Executors.newFixedThreadPool(corePoolSize);
        this.scheduledExecutorService = Executors.newScheduledThreadPool(corePoolSize);
    }

    @Override
    public void schedule(Runnable command, long delay, TimeUnit unit) {
        scheduledExecutorService.schedule(command, delay, unit);
    }

    @Override
    public void scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        scheduledExecutorService.scheduleAtFixedRate(command, initialDelay, period, unit);
    }

    @Override
    public void scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        scheduledExecutorService.scheduleWithFixedDelay(command, initialDelay, delay, unit);
    }

    @Override
    public void shutdown() {
        executorService.shutdown();
        scheduledExecutorService.shutdown();
    }

    @Override
    public List<Runnable> shutdownNow() {
        List<Runnable> runnables = new ArrayList<>();
        runnables.addAll(executorService.shutdownNow());
        runnables.addAll(scheduledExecutorService.shutdownNow());
        return runnables;
    }

    @Override
    public boolean isShutdown() {
        return executorService.isShutdown() && scheduledExecutorService.isShutdown();
    }

    @Override
    public boolean isTerminated() {
        return executorService.isTerminated() && scheduledExecutorService.isTerminated();
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return executorService.awaitTermination(timeout, unit) &&
                scheduledExecutorService.awaitTermination(timeout, unit);
    }

    @Override
    public <T> Future<T> submit(Callable<T> task) {
        return executorService.submit(task);
    }

    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return executorService.submit(task, result);
    }

    @Override
    public Future<?> submit(Runnable task) {
        return executorService.submit(task);
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return executorService.invokeAll(tasks);
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
            throws InterruptedException {
        return executorService.invokeAll(tasks, timeout, unit);
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return executorService.invokeAny(tasks);
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)
            throws InterruptedException, ExecutionException, TimeoutException {
        return executorService.invokeAny(tasks, timeout, unit);
    }

    @Override
    public void execute(Runnable command) {
        executorService.execute(command);
    }
}

/**
 * Output:
 * 
 * Explanation:
 * 
 * The ScheduledExecutorServiceImpl class implements the ScheduledExecutorService interface.
 * It internally uses two executor services: ExecutorService for regular tasks and ScheduledExecutorService for scheduled tasks.
 * The constructor takes the core pool size as a parameter and initializes both executor services with the specified pool size.
 * The schedule method delegates the task to the ScheduledExecutorService to schedule a one-shot action with the given delay.
 * The scheduleAtFixedRate method delegates the task to the ScheduledExecutorService to schedule a periodic action with the given initial delay and period.
 * The scheduleWithFixedDelay method delegates the task to the ScheduledExecutorService to schedule a periodic action with the given initial delay and delay between each execution.
 * The shutdown, shutdownNow, isShutdown, isTerminated, and awaitTermination methods are implemented to gracefully shut down both executor services and provide the necessary functionality.
 * The submit, invokeAll, invokeAny, and execute methods are implemented by delegating the tasks to the ExecutorService.
 * 
 * Note: This implementation assumes that the necessary imports are added at the beginning of the file.
 */
